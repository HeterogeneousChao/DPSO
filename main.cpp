#include <string>
#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>
using namespace std;

// common
#include "common/SUT.h"
// conventional versions
#include "conventional/C_PSO.h"
#include "conventional/C_TVAC.h"
#include "conventional/C_CLPSO.h"
#include "conventional/C_APSO.h"
#include "conventional/C_DMSPSO.h"
// discrete versions
#include "discrete/D_PSO.h"
#include "discrete/D_TVAC.h"
#include "discrete/D_CLPSO.h"
#include "discrete/D_APSO.h"
#include "discrete/D_DMSPSO.h"


// parameters
string alg;			// specified algorithm
string filename;	// input.model and output.ca
SUT *sut;			// the software under test

/*
	commond:
	app algorithm filename.model
		algorithm = cpso | ctvac | cclpso | capso | cdmspso (conventional version)
		          = dpso | dtvac | dclpso | dapso | ddmspso (discrete version)
	output:
		the covering array that is generated by specified algorithm
		and the result is saved in filename.ca
*/
int parseOptions(int argc, char **argv)
{
	if (argc != 3) {
		cout << "Invalid parameter. Failed." << endl;
		return 0;
	}

	// get algorithm
	alg = argv[1];
	string algs[10] = { "cpso", "ctvac", "cclpso", "capso", "cdmspso", "dpso", "dtvac", "dclpso", "dapso", "ddmspso" };
	if (find(algs, algs + 10, alg) == algs + 10)
	{
		cout << "Invalid parameter: algorithm. Failed." << endl;
		return 0;
	}

	// get SUT from filename
	filename = argv[2];
	ifstream infile( filename + ".model" );

	if (infile.is_open())
	{
		string line;

		// parameter
		getline(infile, line);
		int par = atoi(line.substr(line.rfind("parameter") + 10).c_str());

		// value
		int *val = new int[par];
		getline(infile, line);
		string vs = line.substr(line.rfind("value") + 6);
		stringstream ssin(vs);
		int i = 0;
		while (ssin.good() && i < par)
		{
			ssin >> val[i];
			i++;
		}

		// t-way
		getline(infile, line);
		int tway = atoi(line.substr(line.rfind("tway") + 5).c_str());

		// initialize SUT
		sut = new SUT(par, val, tway);

		return 1;
	}
	else
	{
		cout << "Unable to open model file. Failed" << endl;
		return 0;
	}
	
}

int main(int argc, char **argv) 
{
	srand((unsigned int)time(0));

	if (!parseOptions(argc, argv))
		return 0;

	// initialize the PSO generator
	PSO *pso;
	if (alg == "cpso")
		pso = new C_PSO(sut);
	else if (alg == "ctvac")
		pso = new C_TVAC(sut);
	else if (alg == "cclpso")
		pso = new C_CLPSO(sut);
	else if (alg == "capso")
		pso = new C_APSO(sut);
	else if (alg == "cdmspso")
		pso = new C_DMSPSO(sut);
	else if (alg == "dpso")
		pso = new D_PSO(sut);
	else if (alg == "dtvac")
		pso = new D_TVAC(sut);
	else if (alg == "dclpso")
		pso = new D_CLPSO(sut);
	else if (alg == "dapso")
		pso = new D_APSO(sut);
	else if (alg == "ddmspso")
		pso = new D_DMSPSO(sut);
	else
	{
		cout << "Algorithm error. Failed." << endl;
		return 0;
	}

	// set default configuration
	if (alg == "cpso" || alg == "cclpso" || alg == "cdmspso" )
		pso->SetConfig(80, 250, 0.9, 1.3);
	else if (alg == "ctvac" || alg == "capso" )
		pso->SetConfig(80, 250);
	else if (alg == "dpso" || alg == "dclpso" || alg == "ddmspso")
		pso->SetConfig(80, 250, 0.5, 1.3, 0.5, 0.3, 0.7);
	else if (alg == "dtvac" || alg == "dapso")
		pso->SetConfig(80, 250, 0.5, 0.3, 0.7);
	
	// run
	pso->PSOEvolve();

	// output the result
	cout << "size: " << pso->PSO_SIZE << ", time: " << pso->PSO_TIME << endl;

	// write to file
	pso->writeThisResult(filename + ".ca", alg);

	/*
	int p = 10 ;
	int *v = new int[p] ;
	for( int k=0 ; k<p ; k++)
		v[k] = 6 ;
	int t = 2 ;

	SUT *aa = new SUT( p , v ,t );

	PSO *pso = new C_PSO(aa);
	pso->SetConfig( 80 , 250 , 0.9 , 1.3 );
	pso->PSOEvolve();
	cout << "C-final: " << pso->PSO_SIZE << endl;

	PSO *dpso = new D_PSO(aa);
	dpso->SetConfig( 80, 250, 0.5, 1.3, 0.5, 0.3, 0.7);
	dpso->PSOEvolve();
	cout << "D-final: " << dpso->PSO_SIZE << endl;
	*/
	return 0;
}




